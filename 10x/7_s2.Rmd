# S2 Tiles

## Load General Libraries
```{r}
library(tidyverse)
library(sf)
library(ggmap)
```

## Read in Data
```{r}
# read in RDS
# lines.sf <- readRDS("10x/variables/lines_sf.rds")
buses.sf <- readRDS("10x/variables/buses_sf.rds")
map <- readRDS("10x/variables/map_stadia_z14.rds")

# get the bounding box of map
left <- attr(map, "bb")$ll.lon
right <- attr(map, "bb")$ur.lon
bottom <- attr(map, "bb")$ll.lat
top <- attr(map, "bb")$ur.lat
```

## Load S2 Libraries
```{r}
library(s2)
```

## Create Hex Map with S2
```{r}
# set crs
st_crs(buses.sf$geometry) <- 4326
# check for any rows in buses.sf that have a non-numeric value in the voltage column
buses.sf$voltage <- as.numeric(as.character(buses.sf$voltage))
# drop buses with NA voltage
buses.sf <- buses.sf %>% filter(!is.na(voltage)) # drops 248 buses

# convert into s2 geography vector
buses.sf <- buses.sf %>% mutate(s2geo = as_s2_geography(geometry))
buses.sf <- buses.sf %>% mutate(s2cell = as_s2_cell(s2geo))

glimpse(buses.sf)

# get s2 id for each bus
min_res <- 14
max_res <- 18
for (res in min_res:max_res) {
  s2_col <- paste0("s2r", res)
  buses.sf[[s2_col]] <- s2_cell_parent(buses.sf$s2cell, res)
}
glimpse(buses.sf)
```

## Aggregate Data for Each S2 Resolution
```{r}
# aggregate for each resolution
# loop fromo min_res to max_res
buses.s2 <- list()

# Function to aggregate data for each resolution
aggregate_data <- function(res) {
  s2_col <- paste0("s2r", res)
  buses.sf %>%
    group_by(!!sym(s2_col)) %>%
    summarise(
      avg = mean(voltage, na.rm = TRUE),
      stddev = sd(voltage, na.rm = TRUE),
      count = n(),
      res = res
    ) %>%
    rename(s2 = !!sym(s2_col), voltage = avg)
}

# Aggregate data for each resolution
buses.s2 <- lapply(min_res:max_res, aggregate_data)

# Combine data for all resolutions
buses.s2 <- do.call(rbind, buses.s2)
# update geometry from MultiPoint to Polygon
s2poly <- s2_cell_polygon(buses.s2$s2)
s2polygeo <- st_as_sfc(s2poly)
buses.s2 <- st_set_geometry(buses.s2, s2polygeo)
st_geometry(buses.s2)
# add a column "area" with the area of each hex polygon
buses.s2$area <- st_area(buses.s2$geometry)
# inspect before exporting
glimpse(buses.s2)
# export
saveRDS(buses.s2, "10x/variables/buses_s2_r14to15.rds")
```

## Visualize Tiles
```{r}
# import buses.s2 and lines
buses.s2 <- readRDS("10x/variables/buses_s2_r14to18.rds")
# plot just desired resolutions
buses.s2 <- buses.s2 %>% filter(res == 18)

# plot it
s2plot <- ggmap(map) +
  geom_sf(
    data = buses.s2, 
    aes(fill = voltage, color = voltage),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  # geom_sf(
  #   data = lines.sf, 
  #   color="black", 
  #   alpha = 0.05, 
  #   inherit.aes = FALSE
  # ) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish 
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))

ggsave(
  filename = "10x/figures/s2_plot_r18.png", 
  s2plot,
  width = 6480,
  height = 6480,
  dpi = 300,
  units = "px",
  device = "png",
  limitsize = FALSE
)
```


## Distribution Plot V2 for Single-Res Hexes
```{r}
# read in data
buses.sf <- readRDS("10x/variables/buses_sf.rds")
buses.s2 <- readRDS("10x/variables/buses_s2.rds")

# keep just plotted resolution
# buses.s2 <- buses.s2 %>% filter(res == 11)

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = buses.s2,
    aes(x = voltage, weight = area, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```

## Filter Out High Variance Hexes for Multi-Res
```{r}
# define large and small hexes
s2_res_low <- 9
s2_res_med <- 10
s2_res_hi <- 11
s2_res_vhi <- 12

s2_std_dev_max <- 0.003

# read in hexes
buses.s2 <- readRDS("10x/variables/buses_s2.rds")
lines.sf <- readRDS("10x/variables/lines_sf.rds")

# filter out hexes with high variance
buses.s2.low <- buses.s2 %>% 
  filter(res == s2_res_low)

buses.s2.filt.low <- buses.s2 %>% 
  filter(res == s2_res_low & stddev < s2_std_dev_max)

buses.s2.filt.med <- buses.s2 %>%
  filter(res == s2_res_med & stddev < s2_std_dev_max) %>%
  filter(!(s2jsr::get_parent(s2, s2_res_low) %in% buses.s2.filt.low$s2))

buses.s2.filt.hi <- buses.s2 %>%
  filter(res == s2_res_hi) %>%
  filter(!(s2jsr::get_parent(s2, s2_res_low) %in% buses.s2.filt.low$s2)) %>%
  filter(!(s2jsr::get_parent(s2, s2_res_med) %in% buses.s2.filt.med$s2))

buses.s2.filt.vhi <- buses.s2 %>%
  filter(res == s2_res_vhi) %>%
  filter(!(s2jsr::get_parent(s2, s2_res_low) %in% buses.s2.filt.low$s2)) %>%
  filter(!(s2jsr::get_parent(s2, s2_res_med) %in% buses.s2.filt.med$s2)) %>%
  filter(!(s2jsr::get_parent(s2, s2_res_hi) %in% buses.s2.filt.hi$s2))

# recombine hexes
buses.s2.filt <- rbind(buses.s2.low, buses.s2.filt.med, buses.s2.filt.hi, buses.s2.filt.vhi)
buses.s2.filt.true <- rbind(buses.s2.filt.low, buses.s2.filt.med, buses.s2.filt.hi, buses.s2.filt.vhi)
# rm(buses.s2.low, buses.s2.med, buses.s2.hi)

# export filtered hexes
saveRDS(buses.s2.filt, "10x/variables/buses_s2_filt.rds")
saveRDS(buses.s2.filt.true, "10x/variables/buses_s2_filt_true.rds")
```

## Plot Multi-Res Hexes
```{r}
# import buses.s2 and lines
buses.s2.filt <- readRDS("10x/variables/buses_s2_filt.rds")
lines.sf <- readRDS("10x/variables/lines_sf.rds")

# plot multi-res
plot.base <- ggplot() + theme_bw()
plot.lines <- geom_sf(data = lines.sf, color="black", alpha = 0.1)

plot.hex.multires <- plot.base +
  geom_sf(data = buses.s2.filt, aes(fill = voltage), color = NA) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish
  ) +
  plot.lines

plot.hex.multires + ggtitle("Voltage Hexes at Multiple Resolutions & Lines, Res 8-10")
```

## Redo Multi-Res Hexmap for Paper
```{r}
# import buses.s2 and lines
buses.s2.filt <- readRDS("10x/variables/buses_s2_filt.rds")
lines.sf <- readRDS("10x/variables/lines_sf.rds")

# plot it
s2_plot <- ggmap(map) +
  geom_sf(
    data = buses.s2.filt, 
    aes(fill = voltage, color = voltage),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.05, 
    inherit.aes = FALSE
  ) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish 
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))
```


## Distribution Plot for Multi-Res Hex
```{r}
# import filtered hexes
# import buses.sf
buses.sf <- readRDS("10x/variables/buses_sf.rds")
buses.s2.filt <- readRDS("10x/variables/buses_s2_filt.rds")

# calculate the area of each polygon in hex.sf into a column area
buses.s2.filt <- buses.s2.filt %>% mutate(area = drop_units(st_area(geometry)))
# create a new column voltage.rounded that rounds voltage to the nearest 0.001
buses.s2.filt <- buses.s2.filt %>% mutate(voltage.rounded = round(voltage, 3))

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.s2.filt %>% filter(voltage > 0.99 & voltage < 1.04),
    aes(x = voltage.rounded, weight = area),
    fill = "gold",
    color = "gold",
    alpha = 0.5,
    show.legend = TRUE,
    adjust = 1
  ) +
  geom_density(
    data = buses.sf %>% filter(voltage > 0.99 & voltage < 1.04),
     aes(x = voltage, fill = voltage),
    fill = "lightblue",
    color = "lightblue",
    alpha = 0.5,
    show.legend = TRUE,
    adjust = 1
  ) +
  ggtitle("Distribution of Voltages in Actual Buses vs Multi-Res Hex Map, Res 8 & 10") + 
  theme_bw()
```

## Distribution Plot V2 for Hexes
```{r}
# read in data
buses.sf <- readRDS("10x/variables/buses_sf.rds")
buses.s2 <- readRDS("10x/variables/buses_s2.rds")

# calculate the area of each polygon in hex.sf into a column area
buses.s2 <- buses.s2 %>% mutate(area = drop_units(st_area(geometry)))
# create a new column voltage.rounded that rounds voltage to the nearest 0.001
buses.s2 <- buses.s2 %>% mutate(voltage.rounded = round(voltage, 3))

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = buses.s2,
    aes(x = voltage.rounded, weight = area, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```

## Compute Statistics for Hexes
```{r}
# read in data
buses.sf <- readRDS("10x/variables/buses_sf.rds")
buses.s2 <- readRDS("10x/variables/buses_s2.rds")
buses.s2 <- buses.s2 %>% filter(res >= 10 & res <= 12)

# normalize area column
buses.s2$area_norm <- buses.s2$area / sum(buses.s2$area)
set.seed(44)
voltage_sample_s2 <- sample(buses.s2$voltage, 10*nrow(buses.s2), replace = TRUE, prob = buses.s2$area_norm)

# stats
(median(voltage_sample_s2))
(ks.test(buses.sf$voltage, voltage_sample_s2))
(IQR(voltage_sample_s2))
(var(voltage_sample_s2))
(sd(voltage_sample_s2))
(min(buses.s2$voltage))
(max(buses.s2$voltage))
(kurtosis(voltage_sample_s2))

#  show me the 10 buses with the highest voltages out of buses.df
# but just the columns s2 and voltage and count
head(arrange(buses.s2, desc(voltage))$s2, 10)

# find the buses in buses.sf contained within hex 8c283098ab001ff
buses.sf %>% filter(s2r12 == "8c283098ab001ff")

# visuals
boxplot(voltage_sample_s2)
hist(voltage_sample_s2)
```

## Vioplot for Hexes
```{r}
# violin plot
library(vioplot)

par(family = "serif", cex = 1.2)
vioplot(buses.sf$voltage, ylim=c(0.94,1.07), side="left", at=0.97, xaxt='n', yaxt='n', horizontal = TRUE, col = "#929cfc")
vioplot(voltage_sample_s2, ylim=c(0.94,1.07), side="right", at=1.03, add=TRUE, horizontal = TRUE, col = "#fda99c")
title(xlab = "Voltage [p.u.]")
axis(1, at=c(0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0, 1.01, 1.02, 1.03, 1.04, 1.05, 1.06, 1.07))
axis(2, at=c(0.75, 1.25), tick=FALSE, labels = c("Actual", "| Visualized"))
abline(v=1.05, lty=2)
abline(v=.95, lty=2)
# abline(h=1, lty=1)
```


<!-- 
## Run Loops with Multiple Cores
# ```{r}
# Load necessary libraries
# library(foreach)
# library(doParallel)

# # Set the number of cores
# cores <- detectCores()

# # Initialize parallel processing
# cl <- makeCluster(cores, outfile="")
# registerDoParallel(cl)

# # Evaluate necessary code on each cluster worker
# clusterEvalQ(cl, {
#   library(sf)
#   library(s2)
# })
```

## Extract S2 ID for Each Bus
# ```{r}
# Read back in buses.sf
# buses.sf <- readRDS("10x/variables/buses_sf_s2.rds")

# # Define the range of resolutions
# min_res <- 14
# max_res <- 15

# # Export necessary objects to the cluster workers
# clusterExport(cl, c("buses.sf"))

# # Function to compute s2 id for each bus
# compute_s2_id <- function(res) {
#   s2_col <- paste0("s2r", res)
#   buses.sf[[s2_col]] <- s2_cell_parent(buses.sf$s2cell, res)
# }

# # Compute s2 id for each bus in parallel
# foreach(res = min_res:max_res) %dopar% {
#   compute_s2_id(res)
# }

# glimpse(buses.sf)
```

## Aggregate Data for Each S2 Resolution
# ```{r}
# Export necessary objects to the cluster workers
# clusterExport(cl, c("buses.sf"))

# # Function to aggregate data for each resolution
# aggregate_data <- function(res) {
#   s2_col <- paste0("s2r", res)
#   buses.sf %>%
#     group_by(!!sym(s2_col)) %>%
#     summarise(
#       avg = mean(voltage, na.rm = TRUE),
#       stddev = sd(voltage, na.rm = TRUE),
#       count = n(),
#       res = res
#     ) %>%
#     rename(s2 = !!sym(s2_col), voltage = avg)
# }

# # Aggregate data for each resolution in parallel
# buses.s2 <- foreach(res = min_res:max_res) %dopar% {
#   aggregate_data(res)
# }

# # Stop parallel processing
# stopCluster(cl)

# # Combine data for all resolutions
# # buses.s2 <- do.call(rbind, buses.s2)
``` -->