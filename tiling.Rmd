---
title: "tiling"
author: "Isaiah Lyons-Galante"
date: "2023-05-08"
output: html_document
---

# Load Libraries
```{r}
library(tidyverse) # for data reading and processing
library(ggmap) # for getting map backgrounds
library(sf) # for converting data into spatial dfs
library(moments) # for kurtosis
library(tidygraph) # for converting into a network
library(igraph) # for network analysis
library(sp) # for converting to shapefile
library(raster) # for gridding
library(gstat) # for idw
library(vioplot) # for violin plots
library(h3jsr) # for h3 hexes
library(ggvoronoi) # for voronoi
library(units) # for manipulating geometry of voronoi
library(s2)
library(h3) # for h3 idw
```

# Key Datasets
```{r}
buses.sf <- readRDS("./exports/buses_sf.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")
```

# Setup Plotting

## Map
```{r}
library(tidyverse) # for data reading and processing
library(ggmap) # for getting map backgrounds
library(dotenv) # for environment variables

#  define bounding box
bottom <- 37.769
top <- 37.786
left <- -122.238
right <- -122.187

# read in env file
load_dot_env(".env")
google.maps.api.key <- Sys.getenv("GOOGLE_MAPS_API_KEY")
stadia.maps.api.key <- Sys.getenv("STADIA_MAPS_API_KEY")

# configure ggmap with api keys
register_google(google.maps.api.key)
register_stadiamaps(stadia.maps.api.key)

# get background map
map <- ggmap::get_stadiamap(
  bbox = c(
    left = left, 
    right = right, 
    bottom = bottom, 
    top = top
  ), 
  zoom = 17, 
  maptype = "stamen_terrain_lines"
)

# display map
ggmap(map)

# export map as RDS
saveRDS(map, "./exports/map_stadia_z17.rds")
```

# Parsing Data

## Open Voltage DSS Files
```{r}
# read in all of the bus coordinates
buscoords1 <- read.table("./p13u_violations/p13uhs5_1247--p13udt7430/Buscoords.dss", header = FALSE, sep = " ")
buscoords2 <- read.table("./p13u_violations/p13uhs5_1247--p13udt27246/Buscoords.dss", header = FALSE, sep = " ")
buscoords3 <- read.table("./p13u_violations/p13uhs21_1247--p13udt10447/Buscoords.dss", header = FALSE, sep = " ")
buscoords4 <- read.table("./p13u_violations/p13uhs22_1247--p13udt4524/Buscoords.dss", header = FALSE, sep = " ")
buscoords5 <- read.table("./p13u_violations/p13uhs22_1247--p13udt26466/Buscoords.dss", header = FALSE, sep = " ")
buscoords6 <- read.table("./p13u_violations/p13uhs23_1247--p13udt28279/Buscoords.dss", header = FALSE, sep = " ")

# combine the buscoords with rbind
buscoords <- rbind(buscoords1, buscoords2, buscoords3, buscoords4, buscoords5, buscoords6)
colnames(buscoords) <- c("bus", "lng", "lat")
rm(buscoords1, buscoords2, buscoords3, buscoords4, buscoords5, buscoords6)

# read in the bus voltages
busvoltages <- read.csv("./p13u_violations/bus_voltages.csv", header = TRUE, sep = ",")

# replace zero voltages with the system mean
busvoltages$voltage[busvoltages$voltage == 0] <- mean(busvoltages$voltage)

hist(busvoltages$voltage)
# group the buses by bus name and take the mean voltage
busvoltages <- busvoltages %>% group_by(bus) %>% summarise(voltage = mean(voltage))

# merge the buscoords with the busvoltages by the bus name
buses.df <- merge(buscoords, busvoltages, by = "bus")
rm(buscoords, busvoltages)

# change the zero voltage values to 1
buses.df$voltage[buses.df$voltage == 0] <- 1

# create voltage deviation column
buses.df <- buses.df %>% mutate(dev = abs(voltage - 1))

# export buses.df into an RDS object in the exports folder
saveRDS(buses.df, "./exports/buses_df.rds")
```

## Open and Parse Lines DSS Files
```{r}
# read in all of the lines
linesdss1 <- read.table("./p13u_violations/p13uhs5_1247--p13udt7430/Lines.dss", header = FALSE, sep = "\n")
linesdss2 <- read.table("./p13u_violations/p13uhs5_1247--p13udt27246/Lines.dss", header = FALSE, sep = "\n")
linesdss3 <- read.table("./p13u_violations/p13uhs21_1247--p13udt10447/Lines.dss", header = FALSE, sep = "\n")
linesdss4 <- read.table("./p13u_violations/p13uhs22_1247--p13udt4524/Lines.dss", header = FALSE, sep = "\n")
linesdss5 <- read.table("./p13u_violations/p13uhs22_1247--p13udt26466/Lines.dss", header = FALSE, sep = "\n")
linesdss6 <- read.table("./p13u_violations/p13uhs23_1247--p13udt28279/Lines.dss", header = FALSE, sep = "\n")

# combine all lines with rbind
linesdss <- rbind(linesdss1, linesdss2, linesdss3, linesdss4, linesdss5, linesdss6)
rm(linesdss1, linesdss2, linesdss3, linesdss4, linesdss5, linesdss6)

# separate the character strings into columns by the spaces
lines.df <- linesdss %>% separate(V1, into = c("new", "line", "units", "length", "bus1", "bus2", "switch", "enabled", "phases", "linecode"), sep = " ")
rm(linesdss)

# remove any rows that contain any NAs
lines.df <- lines.df %>% drop_na()

# drop the columns new, length, units, switch, enabled, phases, linecode
lines.df <- lines.df %>% select(-new, -length, -units, -switch, -enabled, -phases, -linecode)

# remove the prefix "bus1=" and "bus2=" from the bus1 and bus2 columns
lines.df$bus1 <- gsub("bus1=", "", lines.df$bus1)
lines.df$bus2 <- gsub("bus2=", "", lines.df$bus2)

# remove the characters after the first "." in the columns bus1 and bus2
lines.df$bus1 <- gsub("\\..*", "", lines.df$bus1)
lines.df$bus2 <- gsub("\\..*", "", lines.df$bus2)

# ensure every bus in bus1 and bus2 is in buses.df and remove any that are not # 5 removed
lines.df <- lines.df %>% filter(bus1 %in% buses.df$bus) %>% filter(bus2 %in% buses.df$bus)

# remove any duplicate lines based on bus1 and bus2
lines.df <- lines.df %>% distinct(bus1, bus2, .keep_all = TRUE)

# export
saveRDS(lines.df, "./exports/lines_df.rds")
```

## Read in Transformers
```{r}
# read in all of the lines
txdss1 <- read.table("./p13u_violations/p13uhs5_1247--p13udt7430/Transformers.dss", header = FALSE, sep = "\n")
txdss2 <- read.table("./p13u_violations/p13uhs5_1247--p13udt27246/Transformers.dss", header = FALSE, sep = "\n")
txdss3 <- read.table("./p13u_violations/p13uhs21_1247--p13udt10447/Transformers.dss", header = FALSE, sep = "\n")
txdss4 <- read.table("./p13u_violations/p13uhs22_1247--p13udt4524/Transformers.dss", header = FALSE, sep = "\n")
txdss5 <- read.table("./p13u_violations/p13uhs22_1247--p13udt26466/Transformers.dss", header = FALSE, sep = "\n")
txdss6 <- read.table("./p13u_violations/p13uhs23_1247--p13udt28279/Transformers.dss", header = FALSE, sep = "\n")

# combine all lines with rbind
txdss <- rbind(txdss1, txdss2, txdss3, txdss4, txdss5, txdss6)
rm(txdss1, txdss2, txdss3, txdss4, txdss5, txdss6)

# separate the 2 winding from 3 winding transformers
tx.w2.dss <- txdss %>% filter(grepl("windings=2", V1))
tx.w3.dss <- txdss %>% filter(grepl("windings=3", V1))
rm(txdss)

# separate the character strings into columns by the spaces for each table of windings
tx.w2.df <- tx.w2.dss %>% separate(V1, into = c(
  "New",
  "Transformer",
  "phases",
  "windings",
  "loadloss",
  "Noloadloss",
  "normhkva",
  "wdg1",
  "conn1",
  "Kv1",
  "kva1",
  "EmergHKVA1",
  "r1",
  "bus1",
  "wdg2",
  "conn2",
  "Kv2",
  "kva2",
  "EmergHKVA2",
  "r2",
  "bus2",
  "XHL"
  ), sep = " ")

tx.w3.df <- tx.w3.dss %>% separate(V1, into = c(
  "New",
  "Transformer",
  "phases",
  "windings",
  "loadloss",
  "Noloadloss",
  "normhkva",
  "wdg1",
  "conn1",
  "bus1",
  "Kv1",
  "kva1",
  "EmergHKVA1",
  "r1",
  "wdg2",
  "conn2",
  "bus2",
  "Kv2",
  "kva2",
  "EmergHKVA2",
  "r2",
  "wdg3",
  "conn3",
  "bus3",
  "Kv3",
  "kva3",
  "EmergHKVA3",
  "r3",
  "XHL",
  "XLT",
  "XHT"
  ), sep = " ")

rm(tx.w2.dss, tx.w3.dss)

# Remove extra columns
tx.w3.df <- tx.w3.df %>% select(-New,-phases,-loadloss,-Noloadloss,-normhkva,-wdg1,-conn1,-Kv1,-kva1,-EmergHKVA1,-r1,-wdg2,-conn2,-Kv2,-kva2,-EmergHKVA2,-r2,-wdg3,-conn3,-Kv3,-kva3,-EmergHKVA3,-r3,-XHL,-XLT,-XHT)
tx.w2.df <- tx.w2.df %>% select(-New,-phases,-loadloss,-Noloadloss,-normhkva,-wdg1,-conn1,-Kv1,-kva1,-EmergHKVA1,-r1,-wdg2,-conn2,-Kv2,-kva2,-EmergHKVA2,-r2,-XHL)
tx.w2.df$bus3 <- NA

# Combine into a single df
tx.df <- rbind(tx.w2.df, tx.w3.df)
rm(tx.w2.df, tx.w3.df)

# filter for 3 winding transformers
tx.w3.df <- tx.df %>% filter(windings == 3)
tx.w3.df <- tx.w3.df %>% filter(bus2 != bus3) 
# always equal >> drop the third bus
rm(tx.w3.df)

# drop the bus3 and windings column
tx.df <- tx.df %>% select(-bus3, -windings)
tx.df <- tx.df %>% rename(line = Transformer)

# Remove the prefix "bus=" from the bus names
tx.df$bus1 <- gsub("bus=", "", tx.df$bus1)
tx.df$bus2 <- gsub("bus=", "", tx.df$bus2)

# Remove everything after the period in the bus names
tx.df$bus1 <- gsub("\\..*", "", tx.df$bus1)
tx.df$bus2 <- gsub("\\..*", "", tx.df$bus2)

# export the df as RDS
saveRDS(tx.df, "./exports/tx_df.rds")
```

# Convert to Spatial Data & Visualize

## Convert Buses to Spatial Data Frames
```{r}
library(sf) # for converting data into spatial dfs
# read in buses and lines.df
buses.df <- readRDS("./exports/buses_df.rds")

# convert buses.df to a sf object
buses.sf <- st_as_sf(buses.df, coords = c("lng", "lat"), crs = 4326)

# check of any of the buses share the same geometry -- none do
buses.sf %>% group_by(geometry) %>% summarise(n = n()) %>% filter(n > 1)

# export buses sf as RDS
saveRDS(buses.sf, "./exports/buses_sf.rds")
```

## Convert Lines and Transformers to Spatial Data Frames
```{r}
# read in lines and transformers
lines.df <- readRDS("./exports/lines_df.rds")
tx.df <- readRDS("./exports/tx_df.rds")

# merge into one single df
lines.df <- rbind(lines.df, tx.df)
rm(tx.df)

# merge the lines.df with the buses.df by bus1
lines.df <- merge(lines.df, buses.df, by.x = "bus1", by.y = "bus")
# drop voltage, rename lng to lng1, and lat to lat1
lines.df <- lines.df %>% select(-voltage) %>% rename(lng1 = lng, lat1 = lat)

# merge the lines.df with the buses.df by bus2
lines.df <- merge(lines.df, buses.df, by.x = "bus2", by.y = "bus")
# drop voltage, rename lng to lng2, and lat to lat2
lines.df <- lines.df %>% select(-voltage) %>% rename(lng2 = lng, lat2 = lat)

# rename bus1 to from and bus2 to to
lines.df <- lines.df %>% rename(from = bus1, to = bus2)

linestrings <- apply(lines.df, 1, function(x) 
  {
    v <- as.numeric(x[c("lng1","lng2","lat1","lat2")])
    m <- matrix(v, nrow = 2)
    return(st_sfc(st_linestring(m), crs = 4326))
  }
)

##############################################
linestrings = Reduce(c, linestrings)
lines.df$geometry <- linestrings

# clean up
rm(linestrings)
lines.df <- lines.df %>% select(-lat1, -lat2, -lng1, -lng2)

# convert lines.df to a sf object
lines.sf <- st_as_sf(lines.df, crs = 4326)

# check if any two lines share the same geometry -- 19 do, whatever
# lines.sf.2 <- lines.sf %>% distinct(geometry, .keep_all = TRUE)
 
# export files
saveRDS(lines.sf, "./exports/lines_sf.rds")
```

## Create a Bounding Box around Lines
```{r}
# import lines
lines.sf <- readRDS("./exports/lines_sf.rds")

# merge the lines spatially into a single geometry
lines.all <- st_union(lines.sf)

# create a 50m buffer around lines.all
lines.buffer <- st_buffer(lines.all, endCapStyle = "SQUARE", dist = 100, max_cells = 10000)

# visualize the line buffer
plot(lines.buffer)

# export the line buffer to RDS
saveRDS(lines.buffer, "./exports_envc6/lines_buffer.rds")
```

## Visualize the Lines and Buses
```{r}
# plot it
ggmap(map) +
  geom_sf(
    data = lines.sf, 
    color="yellow", 
    alpha = 1.0, 
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = buses.sf, 
    # aes(color = voltage, cex = dev),
    alpha = 0.5,
    inherit.aes = FALSE,
    cex = 0.7,
    color = "darkgreen"
  ) +
  scale_size_continuous(
    range = c(0, 3),
    limits = c(0, 0.05)
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top)) +
  guides(size = FALSE)
```

## Visualize Glyphs
```{r}
# plot it
glyph_plot <- ggmap(map) +
  geom_sf(
    data = buses.sf, 
    aes(color = voltage, cex = dev),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.2, 
    inherit.aes = FALSE
  ) +
  scale_size_continuous(
    range = c(0, 15),
    limits = c(0, 0.05)
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top)) +
  guides(size = FALSE)

# export an ultra-hi res version of the plot for HRLD
ggsave(
  filename = "figures/glyph_plot_hrld_z17.png", 
  glyph_plot,
  width = 15360,
  height = 6480,
  dpi = 300,
  units = "px",
  device = "png",
  limitsize = FALSE
)
```

## Computate Summary Statistics
```{r}
library(moments) # for kurtosis
# buses.sf <- buses.sf %>% filter(voltage > 0.5)

(v.median <- median(buses.sf$voltage))
(v.ks <- ks.test(buses.sf$voltage, "pnorm", mean(buses.sf$voltage), sd(buses.sf$voltage)))
(v.IQR <- IQR(buses.sf$voltage))
(v.var <- var(buses.sf$voltage))
(v.sd <- sd(buses.sf$voltage))
(v.min <- min(buses.sf$voltage))
(v.max <- max(buses.sf$voltage))

(v.kurtosis <- kurtosis(buses.sf$voltage))
(v.skewness <- skewness(buses.sf$voltage))

boxplot(buses.sf$voltage)
hist(buses.sf$voltage)
```

## Compute Summary Statistics for Glyphs
```{r}
# get the area of the glyph
buses.sf$dev_limited <- ifelse(buses.sf$dev > 0.05, 0.05, buses.sf$dev)
buses.sf$glyph_area <- pi * (buses.sf$dev_limited / 2) ^ 2
buses.sf$glyph_area_weighted <- buses.sf$glyph_area / sum(buses.sf$glyph_area)
set.seed(44)
voltage_sample_glyphs <- sample(buses.sf$voltage, size = 10*nrow(buses.sf), replace = TRUE, prob = buses.sf$glyph_area_weighted)


(median(voltage_sample_glyphs))
(ks.test(buses.sf$voltage, voltage_sample_glyphs))
(wilcox.test(buses.sf$voltage, voltage_sample_glyphs))
(t.test(buses.sf$voltage, voltage_sample_glyphs))
(IQR(voltage_sample_glyphs))
(var(voltage_sample_glyphs))
(sd(voltage_sample_glyphs))
(min(voltage_sample_glyphs))
(max(voltage_sample_glyphs))
(kurtosis(voltage_sample_glyphs))

```

## Vioplot for Glyphs
```{r}
# violin plot
library(vioplot)

par(family = "serif", cex = 1.2)
vioplot(buses.sf$voltage, ylim=c(0.94,1.07), side="left", at=0.97, xaxt='n', yaxt='n', horizontal = TRUE, col = "#929cfc")
vioplot(voltage_sample_glyphs, ylim=c(0.94,1.07), side="right", at=1.03, add=TRUE, horizontal = TRUE, col = "#fda99c")
title(xlab = "Voltage [p.u.]")
axis(1, at=c(0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0, 1.01, 1.02, 1.03, 1.04, 1.05, 1.06, 1.07))
axis(2, at=c(0.75, 1.25), tick=FALSE, labels = c("Actual", "| Visualized"))
abline(v=1.05, lty=2)
abline(v=.95, lty=2)
# abline(h=1, lty=1)
```


## Compare Distribution of Voltages in Glyphs to Actual Voltages
```{r}
# read in buses.idw.sf and buses.sf
# buses.sf <- readRDS("./exports/buses_sf.rds")

# create a density plot of the voltages in buses.sf compared to heatmap
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = buses.sf,
    aes(x = voltage, weight = glyph_area, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```


# Conduct Network Analysis

## Build the Network
```{r}
library(tidygraph)

# reimport
lines.sf <- readRDS("./exports/lines_sf.rds")
buses.sf <- readRDS("./exports/buses_sf.rds")

# ensure all edges have a node
graph <- tbl_graph(
  nodes = buses.sf,
  edges = tibble(lines.sf),
  directed = FALSE
)
saveRDS(graph, "./exports/graph.rds")
```

## Check the Number of Components in the Network
```{r}
# read in the network
graph <- readRDS("./exports/graph.rds")

# calculate components
graph <- graph %>%
  activate(nodes) %>%
  mutate(component = components(graph)$membership)

# plot components by color
ggplot() +
  geom_sf(data = graph %>% activate(edges) %>% as_tibble() %>% st_as_sf(), color = "gray") +
  geom_sf(data = graph %>% activate(nodes) %>% as_tibble() %>% st_as_sf(), size = 0.5, aes(color = component)) +
  scale_color_gradientn(colors = rainbow(1458)) +
  theme_bw()
```

## Force Directed Network Layout FR
```{r}
# library(igraph) # for network analysis
# # read in graph
# graph <- readRDS("./exports/graph.rds")

# # create force directed layout
# fr <- as.data.frame(layout_with_fr(graph, dim = 2))
# ggplot(fr, aes(x = V1, y = V2)) +
#   geom_point(alpha = 0.2, size = 0.5) +
#   theme_bw()
```

## Run Network Analysis
```{r}
library(igraph) # for network analysis
# read in graph and inspect
graph <- readRDS("./exports/graph.rds")
graph
##############################################
# calculate the distances between all nodes
dist_matrix <- distances(graph, mode = "all")
##############################################
# calculate a similarity matrix as 1 / (h+1)^2
sim2_matrix <- 1 / ((dist_matrix + 1)^2)

##############################################
# export matrices
saveRDS(dist_matrix, "./exports/dist_matrix.rds")
saveRDS(sim2_matrix, "./exports/sim2_matrix.rds")

# remove variables from RAM until needed
rm(dist_matrix, sim2_matrix)
```

## Proceed with Weighted Network Analysis
```{r}
# import buses.sf
buses.sf <- readRDS("./exports/buses_sf.rds")
sim2_matrix <- readRDS("./exports/sim2_matrix.rds")

# set up a function to calculate weighted voltage considering n nearest neighbors by hops (including self)
neighbors <- 3

# function to weight voltage
weight_voltage <- function(voltage, row) {
  weights <- sim2_matrix[, row]
  indices <- order(weights, decreasing = TRUE)[1:neighbors]
  vw <- data.frame(
    voltages = buses.sf$voltage[indices],
    weights = weights[indices]
  )
  vw$weighted_voltage <- vw$voltages * vw$weights
  sum_weights <- sum(vw$weights)
  vw$scaled_weighted_voltage <- vw$weighted_voltage / sum_weights
  weighted_voltage <- sum(vw$scaled_weighted_voltage)
  return(weighted_voltage)
}
##############################################
# Apply weighted voltage function to buses.sf
Sys.time()
buses.sf <- buses.sf %>% mutate(
  weighted_voltage_n3_d2 = purrr::map_dbl(
    row_number(),
    ~ weight_voltage(voltage, .x)
  )
)
Sys.time()

# filter out any columns that contain "_dev_"
# buses.sf <- buses.sf %>% select(-contains("_dev_"))

# sort the columns by name
# buses.sf <- buses.sf %>% select(sort(names(.)))

# reexport buses.sf
saveRDS(buses.sf, "./exports/buses_sf.rds")
```

## Plot Weighted Voltage Averages with Glyphs
```{r}
# reimport buses and lines
buses.sf <- readRDS("./exports/buses_sf.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")

# break plot down into components
plot.base <- ggplot() + theme_bw()
plot.lines <- geom_sf(data = lines.sf, color="black", alpha = 0.3)
plot.bus.size <- scale_size_continuous(range = c(0, 2), limits = c(0, 0.05))
plot.bus.color <- scale_color_gradient2(
  low = "darkblue",
  mid = "white",
  high = "darkred",
  midpoint = 1,
  limits = c(0.95, 1.05),
  space = "Lab",
  guide = "colourbar",
  aesthetics = "color",
  oob = scales::squish
)

# plot glyphs
plot.base + 
  plot.lines + 
  geom_sf(
      data = buses.sf, 
      aes(color = weighted_voltage_n10_d2, cex = abs(weighted_voltage_n10_d2 - 1))
    ) +
  plot.bus.size + 
  plot.bus.color +
  ggtitle("Glyphs of Weighted Voltages n=10, d=2")
```

## Read in Important Dataframes
```{r}
############################################################################################################################################################################################################################################################
############################################################################################################################################################################################################################################################
############################################################################################################################################################################################################################################################
############################################################################################################################################################################################################################################################
############################################################################################################################################################################################################################################################
buses.sf <- readRDS("./exports/buses_sf.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")
```

# Heatmaps

## Create a Grid on the Study Area
```{r}
library(sf)
library(sp) # for converting to shapefile
library(raster) # for gridding

# read in dfs
buses.sf <- readRDS("./exports_envc6/buses_sf.rds")
lines.buffer <- readRDS("./exports_envc6/lines_buffer.rds")

# convert buses.sf to sp
buses.sp <- as(buses.sf, "Spatial")

# set number of pixels
n <- 100000

# create a grid within a rectangle of the area
grd <- SpatialPixels(
  SpatialPoints(makegrid(buses.sp, n = n)),
  proj4string = proj4string(buses.sp)
)

# filter grid for areas within original geography
areas.sp <- as(lines.buffer, "Spatial")
grd <- grd[areas.sp, ]
plot(grd)

saveRDS(grd, "./exports_envc6/grd100K.rds")
saveRDS(buses.sp, "./exports_envc6/buses_sp.rds")
```

## Calculate IDW
```{r}
library(gstat) # for idw
# import grd, buses.sp
grd <- readRDS("./exports_envc6/grd.rds")
buses.sp <- readRDS("./exports_envc6/buses_sp.rds")

# set neighbors
neighbors <- 10

##############################################
# print current time
start_time <- Sys.time()
start_time

# create idw into grid
buses.idw <- idw(
  formula = voltage ~ 1,
  buses.sp, grd, idp = 2,
  nmax = neighbors
)

# buses.idw <- idw(
#   formula = weighted_voltage_n10_d2 ~ 1,
#   buses.sp, grd, idp = 2,
#   nmax = neighbors
# )

# print current time
end_time <- Sys.time()
end_time

saveRDS(buses.idw, "./exports_envc6/buses_idw_k10_n1_100k.rds")
```

## Convert Gridded Heatmap to Shapefile
```{r}
# read back in
buses.idw <- readRDS("./exports_envc6/buses_idw_k10_n1_100k.rds")
# plot(buses.idw)

# convert buses.idw to a shapefile
sf <- st_as_sf(buses.idw)

# extract lat long
sf <- sf %>% mutate(
  long = st_coordinates(geometry)[, 1],
  lat = st_coordinates(geometry)[, 2]
)
# rename var1.pred to voltage
sf$voltage <- sf$var1.pred

# drop the columns var1.pred and var1.var from df
sf <- subset(sf, select = -c(var1.pred, var1.var))

# export shapefile as RDS
buses.idw.sf <- sf

# save buses.idw.sf
saveRDS(buses.idw.sf, "./exports_envc6/buses_idw_sf_k10_n1.rds")
```

## Plot the Heatmap
```{r}
buses.idw.sf <- readRDS("./exports/buses_idw_sf_k100_n1.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")

# break plot down into components
plot.base <- ggplot() + theme_bw()
plot.lines <- geom_sf(data = lines.sf, color="black", alpha = 0.1)
plot.bus.size <- scale_size_continuous(range = c(0, 2), limits = c(0, 0.05))
plot.bus.color <- scale_color_gradient2(
  low = "darkblue",
  mid = "white",
  high = "darkred",
  midpoint = 1,
  limits = c(0.95, 1.05),
  space = "Lab",
  guide = "colourbar",
  aesthetics = "color",
  oob = scales::squish
)

# create a ggplot of the heatmap data with the points as tiles
plot.base +
  geom_sf(
    data = buses.idw.sf, 
    aes(colour = voltage),
    size = 1.2,
    shape = 15
  ) +
  plot.lines +
  plot.bus.color +
  ggtitle("Voltage Heatmap with K=2 IDW, N=All, D=2 Weighted Voltages")
```

## Redo Heatmap for Paper
```{r}
# import map
buses.idw.sf <- readRDS("./exports/buses_idw_sf_k1_n1.rds")
map <- readRDS("./exports/map_stadia_z17.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")

# plot it
heatmap_plot <- ggmap(map) +
  geom_sf(
    data = buses.idw.sf, 
    aes(color = voltage),
    alpha = 1.0,
    size = 5,
    shape = 15,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.05, 
    inherit.aes = FALSE
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))

ggsave(
  filename = "figures/heatmap_plot_hrld_z17.png", 
  heatmap_plot,
  width = 15360,
  height = 6480,
  dpi = 300,
  units = "px",
  device = "png",
  limitsize = FALSE
)
```

## Compare Distribution of Voltages in Heatmap to Actual Voltages
```{r}
# read in buses.idw.sf and buses.sf
buses.sf <- readRDS("./exports/buses_sf.rds")

# create a density plot of the voltages in buses.sf compared to heatmap
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = buses.idw.sf,
    aes(x = voltage, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```

## Computate Summary Statistics
```{r}
# read in buses.idw.sf
buses.idw.sf <- readRDS("./exports/buses_idw_sf_k1_n10.rds")
buses.sf <- readRDS("./exports/buses_sf.rds")

(median(buses.idw.sf$voltage))
(ks.test(buses.sf$voltage, buses.idw.sf$voltage))
(wilcox.test(buses.sf$voltage, buses.idw.sf$voltage))
(t.test(buses.sf$voltage, buses.idw.sf$voltage))
(IQR(buses.idw.sf$voltage))
(var(buses.idw.sf$voltage))
(sd(buses.idw.sf$voltage))
(min(buses.idw.sf$voltage))
(max(buses.idw.sf$voltage))
(kurtosis(buses.idw.sf$voltage))
```

## Violin Plot for Heatmap
```{r}
# import dfs
# buses.idw.sf <- readRDS("./exports/buses_idw_sf_k1_n10.rds")
# buses.sf <- readRDS("./exports/buses_sf.rds")

# try color gradient
# n <- nrow(buses.sf)
# redblue <- colorRampPalette(c("blue", "white", "red"))
# redblue(n)

# violin plot
library(vioplot)

par(family = "serif", cex = 1.2)
vioplot(buses.sf$voltage, ylim=c(0.94,1.07), side="left", at=0.97, xaxt='n', yaxt='n', horizontal = TRUE, col = "#929cfc")
vioplot(buses.idw.sf$voltage, ylim=c(0.94,1.07), side="right", at=1.03, add=TRUE, horizontal = TRUE, col = "#fda99c")
title(xlab = "Voltage [p.u.]")
axis(1, at=c(0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0, 1.01, 1.02, 1.03, 1.04, 1.05, 1.06, 1.07))
axis(2, at=c(0.75, 1.25), tick=FALSE, labels = c("Actual", "| Visualized"))
abline(v=1.05, lty=2)
abline(v=.95, lty=2)
# abline(h=1, lty=1)
```

## Redo IDW Manually
```{r}
# read in sf objects
buses.sf <- readRDS("./exports/buses_sf.rds")
# lines.sf <- readRDS("./exports/lines_sf.rds")

#  read in network and distance matrices
# graph <- readRDS("./exports/graph.rds")
# dist_matrix <- readRDS("./exports/dist_matrix.rds")
# sim2_matrix <- readRDS("./exports/sim2_matrix.rds")

# read in buses.sf, grd, and buses.sp
grd <- readRDS("./exports/grd1k.rds")

# convert grd from SpatialPixelsDataFrame to sf object
grd.sf <- st_as_sf(grd)

# find the euclidian distance between all points in grd and buses.sp
Sys.time()
dist_grd_matrix <- st_distance(grd.sf, buses.sf)
Sys.time()

# export dist_grd_matrix
saveRDS(dist_grd_matrix, "./exports/dist_grd_matrix.rds")
dist_grd_matrix_inv_sq <- 1 / dist_grd_matrix ^ 2


# set neighbors
nmax <- 10

# set max number of hops away to count
hmax <- 5

# network weights
dist_matrix <- ifelse(dist_matrix <= hmax, 1, 0)

# recreate idw
grd.sf$voltage <- apply(
  X = dist_grd_matrix_inv_sq,
  MARGIN = 1,
  FUN = function(x) {
    # get the indices of the nmax largest values
    indices <- order(x, decreasing = TRUE)[1:nmax]
    # get the voltages of the nmax largest values
    voltages <- buses.sf$voltage[indices]
    # get the weights of the nmax largest values
    weights <- x[indices]

    # calculate the weighted voltage
    weighted_voltage <- sum(voltages * weights) / sum(weights)
    # return the weighted voltage
    return(weighted_voltage)
  }
)

# add in network weightings
grd.sf$topo_voltage <- apply(
  X = dist_grd_matrix_inv_sq,
  MARGIN = 1,
  FUN = function(x) {
    nn_index <- order(x, decreasing = TRUE)[1]
    # get the indices of the nmax largest values
    indices <- order(x, decreasing = TRUE)[1:nmax]
    # get the voltages of the nmax largest values
    voltages <- buses.sf$voltage[indices]
    # get the weights of the nmax largest values
    weights <- x[indices]
    # calculate the weighted voltage
    weighted_voltage <- sum(voltages * weights) / sum(weights)
    # return the weighted voltage
    return(weighted_voltage)
  }
)


# import map
map <- readRDS("./exports/map_stadia_z17.rds")

# plot it
ggmap(map) +
  geom_sf(
    data = grd.sf, 
    aes(color = voltage),
    alpha = 1.0,
    size = 15,
    shape = 15,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.05, 
    inherit.aes = FALSE
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))


# print current time
# start_time <- Sys.time()
# start_time

# create idw into grid
# buses.idw <- idw(
#   formula = weighted_voltage_n1 ~ 1,
#   buses.sp, grd, idp = 2,
#   nmax = neighbors
# )
# print current time
# end_time <- Sys.time()
# end_time
# saveRDS(buses.idw, "./exports/buses_idw_k1000_n1.rds")



# # set up a function to calculate weighted voltage considering n nearest neighbors by hops
# neighbors <- 3

# # function to weight voltage
# weight_voltage <- function(voltage, row) {
#   weights <- sim2_matrix[, row]
#   indices <- order(weights, decreasing = TRUE)[1:neighbors]
#   vw <- data.frame(
#     voltages = buses.sf$voltage[indices],
#     weights = weights[indices]
#   )
#   vw$weighted_voltage <- vw$voltages * vw$weights
#   sum_weights <- sum(vw$weights)
#   vw$scaled_weighted_voltage <- vw$weighted_voltage / sum_weights
#   weighted_voltage <- sum(vw$scaled_weighted_voltage)
#   return(weighted_voltage)
# }

# # Apply weighted voltage function to buses.sf
# buses.sf <- buses.sf %>% mutate(
#   weighted_voltage_n3_d2 = purrr::map_dbl(
#     row_number(),
#     ~ weight_voltage(voltage, .x)
#   )
# )


```


# H3 Tiles

## Create Hex Map with H3
```{r}
library(h3jsr)
library(tidyverse)
# read in buses.sf
buses.sf <- readRDS("./exports_envc6/buses_sf.rds")

# set crs
st_crs(buses.sf$geometry) <- 4326

# get h3 id for each
buses.sf <- buses.sf %>% mutate(h3r8 = point_to_cell(geometry, res = 8, simple = TRUE))
buses.sf <- buses.sf %>% mutate(h3r9 = point_to_cell(geometry, res = 9, simple = TRUE))
buses.sf <- buses.sf %>% mutate(h3r10 = point_to_cell(geometry, res = 10, simple = TRUE))
buses.sf <- buses.sf %>% mutate(h3r11 = point_to_cell(geometry, res = 11, simple = TRUE))
buses.sf <- buses.sf %>% mutate(h3r12 = point_to_cell(geometry, res = 12, simple = TRUE))
buses.sf <- buses.sf %>% mutate(h3r13 = point_to_cell(geometry, res = 13, simple = TRUE))

# aggregate for each resolution
buses.h3.r8 <- buses.sf %>% group_by(h3r8) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(),
  res = 8
) %>% rename(h3 = h3r8, voltage = avg)

buses.h3.r9 <- buses.sf %>% group_by(h3r9) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(),
  res = 9
) %>% rename(h3 = h3r9, voltage = avg)

buses.h3.r10 <- buses.sf %>% group_by(h3r10) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(),
  res = 10
) %>% rename(h3 = h3r10, voltage = avg)

buses.h3.r11 <- buses.sf %>% group_by(h3r11) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(), 
  res = 11
) %>% rename(h3 = h3r11, voltage = avg)

buses.h3.r12 <- buses.sf %>% group_by(h3r12) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(), 
  res = 12
) %>% rename(h3 = h3r12, voltage = avg)

# buses.h3.r13 <- buses.sf %>% group_by(h3r13) %>% summarise(
#   avg = mean(voltage),
#   stddev = sd(voltage),
#   count = n(), 
#   res = 13
# ) %>% rename(h3 = h3r13, voltage = avg)

# combine buses.h3.r9 and buses.h3.r10 and buses.h3.r11
# buses.h3 <- rbind(buses.h3.r10, buses.h3.r11, buses.h3.r12)
buses.h3 <- rbind(buses.h3.r8, buses.h3.r9, buses.h3.r10, buses.h3.r11, buses.h3.r12)
buses.h3 <- buses.h3.r11

# rm(buses.h3.r8, buses.h3.r9, buses.h3.r10, buses.h3.r11, buses.h3.r12)

# update geometry
buses.h3$geometry <- cell_to_polygon(buses.h3$h3)

# add a column "area" with the area of each hex polygon
# buses.h3$area <- st_area(buses.h3$geometry)

saveRDS(buses.h3, "./exports_envc6/buses_h3.rds")
```

## Visualize Hexes
```{r}
# import buses.h3 and lines
buses.h3 <- readRDS("./exports/buses_h3.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")

# define desired resolution
# res <- 9

# plot just a single resolution
# buses.h3 <- buses.h3 %>% filter(res == res)

plot.base <- ggplot() + theme_bw()
plot.lines <- geom_sf(data = lines.sf, color="black", alpha = 0.1)

plot.hex <- plot.base +
  geom_sf(data = buses.h3, aes(fill = voltage, color = voltage)) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  plot.lines

plot.hex + ggtitle(paste(c("Voltage Hexes & Lines, Res", res), collapse = " "))
plot.hex + ggtitle("Voltage Hexes & Lines, Res 9-11")
```

## Redo Hexmap for Paper
```{r}
# import buses.h3 and lines
buses.h3 <- readRDS("./exports/buses_h3.rds")
map <- readRDS("./exports/map_stadia_z17.rds")

# plot just desired resolutions
# buses.h3 <- buses.h3 %>% filter(res != 8 & res != 9)

# plot it
ggmap(map) +
  geom_sf(
    data = buses.h3, 
    aes(fill = voltage, color = voltage),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.05, 
    inherit.aes = FALSE
  ) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish 
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),    
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))

ggsave(
  filename = "figures/voronoi_plot_hrld_z17.png", 
  voronoi_plot,
  width = 15360,
  height = 6480,
  dpi = 300,
  units = "px",
  device = "png",
  limitsize = FALSE
)
```


## Distribution Plot V2 for Single-Res Hexes
```{r}
# read in data
buses.sf <- readRDS("./exports/buses_sf.rds")
buses.h3 <- readRDS("./exports/buses_h3.rds")

# keep just plotted resolution
# buses.h3 <- buses.h3 %>% filter(res == 11)

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = buses.h3,
    aes(x = voltage, weight = area, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```

## Filter Out High Variance Hexes for Multi-Res
```{r}
# define large and small hexes
h3_res_low <- 9
h3_res_med <- 10
h3_res_hi <- 11
h3_res_vhi <- 12

h3_std_dev_max <- 0.003

# read in hexes
buses.h3 <- readRDS("./exports/buses_h3.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")

# filter out hexes with high variance
buses.h3.low <- buses.h3 %>% 
  filter(res == h3_res_low)

buses.h3.filt.low <- buses.h3 %>% 
  filter(res == h3_res_low & stddev < h3_std_dev_max)

buses.h3.filt.med <- buses.h3 %>%
  filter(res == h3_res_med & stddev < h3_std_dev_max) %>%
  filter(!(h3jsr::get_parent(h3, h3_res_low) %in% buses.h3.filt.low$h3))

buses.h3.filt.hi <- buses.h3 %>%
  filter(res == h3_res_hi) %>%
  filter(!(h3jsr::get_parent(h3, h3_res_low) %in% buses.h3.filt.low$h3)) %>%
  filter(!(h3jsr::get_parent(h3, h3_res_med) %in% buses.h3.filt.med$h3))

buses.h3.filt.vhi <- buses.h3 %>%
  filter(res == h3_res_vhi) %>%
  filter(!(h3jsr::get_parent(h3, h3_res_low) %in% buses.h3.filt.low$h3)) %>%
  filter(!(h3jsr::get_parent(h3, h3_res_med) %in% buses.h3.filt.med$h3)) %>%
  filter(!(h3jsr::get_parent(h3, h3_res_hi) %in% buses.h3.filt.hi$h3))

# recombine hexes
buses.h3.filt <- rbind(buses.h3.low, buses.h3.filt.med, buses.h3.filt.hi, buses.h3.filt.vhi)
buses.h3.filt.true <- rbind(buses.h3.filt.low, buses.h3.filt.med, buses.h3.filt.hi, buses.h3.filt.vhi)
# rm(buses.h3.low, buses.h3.med, buses.h3.hi)

# export filtered hexes
saveRDS(buses.h3.filt, "./exports/buses_h3_filt.rds")
saveRDS(buses.h3.filt.true, "./exports/buses_h3_filt_true.rds")
```

## Plot Multi-Res Hexes
```{r}
# import buses.h3 and lines
buses.h3.filt <- readRDS("./exports/buses_h3_filt.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")

# plot multi-res
plot.base <- ggplot() + theme_bw()
plot.lines <- geom_sf(data = lines.sf, color="black", alpha = 0.1)

plot.hex.multires <- plot.base +
  geom_sf(data = buses.h3.filt, aes(fill = voltage), color = NA) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish
  ) +
  plot.lines

plot.hex.multires + ggtitle("Voltage Hexes at Multiple Resolutions & Lines, Res 8-10")
```

## Redo Multi-Res Hexmap for Paper
```{r}
# import buses.h3 and lines
buses.h3.filt <- readRDS("./exports/buses_h3_filt.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")

# plot it
h3_plot <- ggmap(map) +
  geom_sf(
    data = buses.h3.filt, 
    aes(fill = voltage, color = voltage),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.05, 
    inherit.aes = FALSE
  ) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish 
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))
```


## Distribution Plot for Multi-Res Hex
```{r}
# import filtered hexes
# import buses.sf
buses.sf <- readRDS("./exports/buses_sf.rds")
buses.h3.filt <- readRDS("./exports/buses_h3_filt.rds")

# calculate the area of each polygon in hex.sf into a column area
buses.h3.filt <- buses.h3.filt %>% mutate(area = drop_units(st_area(geometry)))
# create a new column voltage.rounded that rounds voltage to the nearest 0.001
buses.h3.filt <- buses.h3.filt %>% mutate(voltage.rounded = round(voltage, 3))

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.h3.filt %>% filter(voltage > 0.99 & voltage < 1.04),
    aes(x = voltage.rounded, weight = area),
    fill = "gold",
    color = "gold",
    alpha = 0.5,
    show.legend = TRUE,
    adjust = 1
  ) +
  geom_density(
    data = buses.sf %>% filter(voltage > 0.99 & voltage < 1.04),
     aes(x = voltage, fill = voltage),
    fill = "lightblue",
    color = "lightblue",
    alpha = 0.5,
    show.legend = TRUE,
    adjust = 1
  ) +
  ggtitle("Distribution of Voltages in Actual Buses vs Multi-Res Hex Map, Res 8 & 10") + 
  theme_bw()
```

## Distribution Plot V2 for Hexes
```{r}
# read in data
buses.sf <- readRDS("./exports/buses_sf.rds")
buses.h3 <- readRDS("./exports/buses_h3.rds")

# calculate the area of each polygon in hex.sf into a column area
buses.h3 <- buses.h3 %>% mutate(area = drop_units(st_area(geometry)))
# create a new column voltage.rounded that rounds voltage to the nearest 0.001
buses.h3 <- buses.h3 %>% mutate(voltage.rounded = round(voltage, 3))

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = buses.h3,
    aes(x = voltage.rounded, weight = area, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```

## Compute Statistics for Hexes
```{r}
# read in data
buses.sf <- readRDS("./exports/buses_sf.rds")
buses.h3 <- readRDS("./exports/buses_h3.rds")
buses.h3 <- buses.h3 %>% filter(res >= 10 & res <= 12)

# normalize area column
buses.h3$area_norm <- buses.h3$area / sum(buses.h3$area)
set.seed(44)
voltage_sample_h3 <- sample(buses.h3$voltage, 10*nrow(buses.h3), replace = TRUE, prob = buses.h3$area_norm)

# stats
(median(voltage_sample_h3))
(ks.test(buses.sf$voltage, voltage_sample_h3))
(IQR(voltage_sample_h3))
(var(voltage_sample_h3))
(sd(voltage_sample_h3))
(min(buses.h3$voltage))
(max(buses.h3$voltage))
(kurtosis(voltage_sample_h3))

#  show me the 10 buses with the highest voltages out of buses.df
# but just the columns h3 and voltage and count
head(arrange(buses.h3, desc(voltage))$h3, 10)

# find the buses in buses.sf contained within hex 8c283098ab001ff
buses.sf %>% filter(h3r12 == "8c283098ab001ff")

# visuals
boxplot(voltage_sample_h3)
hist(voltage_sample_h3)
```

## Vioplot for Hexes
```{r}
# violin plot
library(vioplot)

par(family = "serif", cex = 1.2)
vioplot(buses.sf$voltage, ylim=c(0.94,1.07), side="left", at=0.97, xaxt='n', yaxt='n', horizontal = TRUE, col = "#929cfc")
vioplot(voltage_sample_h3, ylim=c(0.94,1.07), side="right", at=1.03, add=TRUE, horizontal = TRUE, col = "#fda99c")
title(xlab = "Voltage [p.u.]")
axis(1, at=c(0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0, 1.01, 1.02, 1.03, 1.04, 1.05, 1.06, 1.07))
axis(2, at=c(0.75, 1.25), tick=FALSE, labels = c("Actual", "| Visualized"))
abline(v=1.05, lty=2)
abline(v=.95, lty=2)
# abline(h=1, lty=1)
```

# Voronoi

## Create tesselation
```{r}
library(ggvoronoi) # for creating voronoi polygons
library(units) # for manipulating geometry of voronoi
# read in buses.sf
buses.sf <- readRDS("./exports/buses_sf.rds")
lines.buffer <- readRDS("./exports/lines_buffer.rds")

# convert lines.buffer from an sfc_POLYGON to SpatialPolygonsDataFrame
lines.buffer.sp <- as(lines.buffer, "Spatial")


# extract lat and lng from buses.sf
buses.sf <- buses.sf %>% mutate(
  lng = st_coordinates(geometry)[, 1],
  lat = st_coordinates(geometry)[, 2]
)

# convert buses.sf from an sfc_POINT to data.frame
buses.df <- as.data.frame(buses.sf)

############################################################
# create voronoi tesselation SpatialPolygon
voronoi.sp <- ggvoronoi::voronoi_polygon(
  buses.df,
  x = "lng", 
  y = "lat",
  outline = lines.buffer.sp
)

############################################################
# convert voronoi SpatialPolygon to a shapefile
voronoi.sf <- sf::st_as_sf(voronoi.sp)

# set projection of sf to ESPG:4326
voronoi.sf <- sf::st_set_crs(voronoi.sf, 4326)

# calculate the area of each polygon in voronoi.sf into a column area
voronoi.sf <- voronoi.sf %>% mutate(area = drop_units(st_area(geometry)))

# create a new column voltage.rounded that rounds voltage to the nearest 0.001
voronoi.sf <- voronoi.sf %>% mutate(voltage.rounded = round(voltage, 3))

# export
saveRDS(voronoi.sf, "./exports_envc6/voronoi_sf.rds")
saveRDS(voronoi.sp, "./exports_envc6/voronoi_sp.rds")
```


## Plot Voronoi Tesselations
```{r}
# read in voronoi.sf
voronoi.sf <- readRDS("./exports/voronoi_sf.rds")
offset <- 0.00
squeeze <- 0.00
# plot them
ggplot() + 
  geom_sf(data = voronoi.sf, aes(fill = voltage, color = voltage)) +
  geom_sf(data = lines.sf, color="black", alpha = 0.1) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1 + offset,
    limits = c(0.95 + offset + squeeze, 1.05 + offset - squeeze),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1 + offset,
    limits = c(0.95 + offset + squeeze, 1.05 + offset - squeeze),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  ggtitle("Voronoi Tesselation") +
  theme_bw()

# plot distribution of voltages
ggplot() +
  geom_density(
    data = voronoi.sf %>% filter(voltage > 0.99 & voltage < 1.04),
    aes(x = voltage.rounded, weight = area),
    fill = "gold",
    color = "gold",
    alpha = 0.5,
    show.legend = TRUE,
    adjust = 5
  ) +
  geom_density(
    data = buses.sf %>% filter(voltage > 0.99 & voltage < 1.04),
     aes(x = voltage, fill = voltage),
    fill = "lightblue",
    color = "lightblue",
    alpha = 0.5,
    show.legend = TRUE,
    adjust = 5
  ) +
  ggtitle("Distribution of Voltages in Actual Buses vs Voronoi Map No Weights") + 
  theme_bw()
```

## Replot Voronoi for Paper
```{r}
# read in voronoi.sf
voronoi.sf <- readRDS("./exports/voronoi_sf.rds")
map <- readRDS("./exports/map_stadia_z17.rds")

# plot it
voronoi_plot <- ggmap(map) +
  geom_sf(
    data = voronoi.sf, 
    aes(fill = voltage, color = voltage),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.1, 
    inherit.aes = FALSE
  ) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(), 
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))

ggsave(
  filename = "figures/voronoi_plot_hrld_z17.png", 
  voronoi_plot,
  width = 15360,
  height = 6480,
  dpi = 300,
  units = "px",
  device = "png",
  limitsize = FALSE
)
```

## Distribution Plot V2 for Voronoi
```{r}
# read in data
buses.sf <- readRDS("./exports/buses_sf.rds")
voronoi.sf <- readRDS("./exports/voronoi_sf.rds")

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = voronoi.sf,
    aes(x = sample_voltage, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```

## Computate Summary Statistics
```{r}
voronoi.sf <- readRDS("./exports/voronoi_sf.rds")

voronoi.sf$weightedarea <- voronoi.sf$area / sum(voronoi.sf$area)
# voronoi.sf$areavoltage <- voronoi.sf$area * voronoi.sf$voltage
# voronoi.sf$voltage.area.weighted <- voronoi.sf$areavoltage / mean(voronoi.sf$area)
nrow(voronoi.sf)
set.seed(44)
voltage_sample_voronoi <- sample(voronoi.sf$voltage, size = 10*nrow(voronoi.sf), replace = TRUE, prob = voronoi.sf$weightedarea)

# stats
(median(voltage_sample_voronoi))
(ks.test(buses.sf$voltage, voltage_sample_voronoi))
(IQR(voltage_sample_voronoi))
(var(voltage_sample_voronoi))
(sd(voltage_sample_voronoi))
(min(voltage_sample_voronoi))
(max(voltage_sample_voronoi))
(kurtosis(voltage_sample_voronoi))

# visuals
boxplot(voltage_sample_voronoi)
hist(voltage_sample_voronoi)
```

## Vioplot for Voronoi
```{r}
# violin plot
library(vioplot)

par(family = "serif", cex = 1.2)
vioplot(buses.sf$voltage, ylim=c(0.94,1.07), side="left", at=0.97, xaxt='n', yaxt='n', horizontal = TRUE, col = "#929cfc")
vioplot(voltage_sample_voronoi, ylim=c(0.94,1.07), side="right", at=1.03, add=TRUE, horizontal = TRUE, col = "#fda99c")
title(xlab = "Voltage [p.u.]")
axis(1, at=c(0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0, 1.01, 1.02, 1.03, 1.04, 1.05, 1.06, 1.07))
axis(2, at=c(0.75, 1.25), tick=FALSE, labels = c("Actual", "| Visualized"))
abline(v=1.05, lty=2)
abline(v=.95, lty=2)
# abline(h=1, lty=1)
```

# S2 Tiles

## Create S2 Tiles
```{r}
library(s2)
# read in buses.sf
buses.sf <- readRDS("./exports_envc6/buses_sf.rds")

# set resolution
s2_res_low <- 16
s2_res_med <- 17
s2_res_hi <- 18
s2_res_vhi <- 19

# convert into s2 geography vector
buses.sf <- buses.sf %>% mutate(s2geo = as_s2_geography(geometry))
buses.sf <- buses.sf %>% mutate(s2cell = as_s2_cell(s2geo))

# return the parent of cell s2 at resolution res
buses.sf <- buses.sf %>% mutate(s2vhi = s2_cell_parent(s2cell, s2_res_vhi))
buses.sf <- buses.sf %>% mutate(s2hi = s2_cell_parent(s2cell, s2_res_hi))
buses.sf <- buses.sf %>% mutate(s2med = s2_cell_parent(s2cell, s2_res_med))
buses.sf <- buses.sf %>% mutate(s2low = s2_cell_parent(s2cell, s2_res_low))


# group by each resolution
buses.s2.low <- buses.sf %>% group_by(s2low) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(),
  res = s2_res_low
) %>% rename(s2 = s2low, voltage = avg)

buses.s2.med <- buses.sf %>% group_by(s2med) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(),
  res = s2_res_med
) %>% rename(s2 = s2med, voltage = avg)

buses.s2.hi <- buses.sf %>% group_by(s2hi) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(),
  res = s2_res_hi
) %>% rename(s2 = s2hi, voltage = avg)

# aggregate for each resolution
buses.s2.vhi <- buses.sf %>% group_by(s2vhi) %>% summarise(
  avg = mean(voltage),
  stddev = sd(voltage),
  count = n(),
  res = s2_res_vhi
) %>% rename(s2 = s2vhi, voltage = avg)

# combine buses.s2.low, buses.s2.med, buses.s2.hi
# buses.s2 <- rbind(buses.s2.low, buses.s2.med, buses.s2.hi, buses.s2.vhi)
buses.s2 <- buses.s2.med
buses.s2 <- rbind(buses.s2.low, buses.s2.med, buses.s2.hi)
rm(buses.s2.low, buses.s2.med, buses.s2.hi)

s2poly <- s2_cell_polygon(buses.s2$s2)
s2polygeo <- st_as_sfc(s2poly)
buses.s2 <- st_set_geometry(buses.s2, s2polygeo)
st_geometry(buses.s2)

# export buses.s2
saveRDS(buses.s2, "./exports_envc6/buses_s2.rds")
```

## Plot S2 Tiles
```{r}
# read in buses.s2
buses.s2 <- readRDS("./exports/buses_s2.rds")
lines.sf <- readRDS("./exports/lines_sf.rds")
map <- readRDS("./exports/map_stadia_z17.rds")

# plot just desired resolutions
# buses.s2 <- buses.s2 %>% filter(res != s2_res_low)

# plot it
ggmap(map) +
  geom_sf(
    data = buses.s2, 
    aes(fill = voltage, color = voltage),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.05, 
    inherit.aes = FALSE
  ) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish 
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))
```

## Filter S2 Tiles to Create Multiple Resolutions
```{r}
# set resolution
s2_res_low <- 16
s2_res_med <- 17
s2_res_hi <- 18
s2_res_vhi <- 19

std_dev_max <- 0.003

# read in buses.s2
buses.s2 <- readRDS("./exports/buses_s2.rds")

# filter out buses with a NA std dev
buses.s2$stddev[is.na(buses.s2$stddev)] <- 0

# get low resolution tiles as a base layer
buses.s2.low <- buses.s2 %>% 
  filter(res == s2_res_low)

# filter out tiles with high std_dev from s2hi
buses.s2.low.filt <- buses.s2 %>% 
  filter(res == s2_res_low & stddev < std_dev_max)

# filter out children of these tiles
buses.s2.med.filt <- buses.s2 %>% 
  filter(res == s2_res_med & stddev < std_dev_max) %>%
  filter(!(s2::s2_cell_parent(s2, s2_res_low) %in% buses.s2.low.filt$s2))

# filter out children of both of these tiles
buses.s2.hi.filt <- buses.s2 %>% 
  filter(res == s2_res_hi & stddev < std_dev_max) %>%
  filter(!(s2::s2_cell_parent(s2, s2_res_med) %in% buses.s2.med.filt$s2))  %>%
  filter(!(s2::s2_cell_parent(s2, s2_res_low) %in% buses.s2.low.filt$s2))

# filter out children of both of these tiles
# buses.s2.vhi.filt <- buses.s2 %>% 
#   filter(res == s2_res_vhi) %>%
#   filter(!(s2::s2_cell_parent(s2, s2_res_hi) %in% buses.s2.hi.filt$s2))  %>%
#   filter(!(s2::s2_cell_parent(s2, s2_res_med) %in% buses.s2.med.filt$s2))  %>%
#   filter(!(s2::s2_cell_parent(s2, s2_res_low) %in% buses.s2.low.filt$s2))

# combine buses.s2.low.filt, buses.s2.med.filt
buses.s2.filt <- rbind(
  buses.s2.low, 
  buses.s2.med.filt, 
  buses.s2.hi.filt
  # buses.s2.vhi.filt
)

# create for distribution plots
buses.s2.filt.true <- rbind(
  buses.s2.low.filt, 
  buses.s2.med.filt, 
  buses.s2.hi.filt
  # buses.s2.vhi.filt
)

# clean up variables
rm(buses.s2.low, buses.s2.low.filt, buses.s2.med.filt, buses.s2.hi.filt)

# calculate the area of each polygon into a column area
buses.s2.filt.true <- buses.s2.filt.true %>% mutate(area = drop_units(st_area(geometry)))

# create a new column voltage.rounded that rounds voltage to the nearest 0.001
buses.s2.filt.true <- buses.s2.filt.true %>% mutate(voltage.rounded = round(voltage, 3))

# check geometry to ensure it's a polygon
st_geometry(buses.s2.filt.true)

# export filtered tiles
saveRDS(buses.s2.filt, "./exports/buses_s2_filt.rds")
saveRDS(buses.s2.filt.true, "./exports/buses_s2_filt_true.rds")
```

## Plot Filtered S2 Tiles
```{r}
lines.sf <- readRDS("./exports/lines_sf.rds")
map <- readRDS("./exports/map_stadia_z17.rds")
buses.s2.filt <- readRDS("./exports/buses_s2_filt.rds")

# plot it
s2_plot <- ggmap(map) +
  geom_sf(
    data = buses.s2.filt, 
    aes(fill = voltage, color = voltage),
    alpha = 1.0,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = lines.sf, 
    color="black", 
    alpha = 0.05, 
    inherit.aes = FALSE
  ) +
  scale_fill_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",    
    guide = "colourbar",
    aesthetics = "fill",
    oob = scales::squish 
  ) +
  scale_color_gradient2(
    low = "darkblue",
    mid = "white",
    high = "darkred",
    midpoint = 1,
    limits = c(0.95, 1.05),
    space = "Lab",
    guide = "colourbar",
    aesthetics = "color",
    oob = scales::squish
  ) +
  theme(
    legend.position = c(0.96, 0.15),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(), 
    text = element_text(family = "Serif", size = 18)
  ) +
  coord_sf(xlim = c(left, right), ylim = c(bottom, top))

ggsave(
  filename = "figures/s2_plot_hrld_z17.png", 
  s2_plot,
  width = 15360,
  height = 6480,
  dpi = 300,
  units = "px",
  device = "png",
  limitsize = FALSE
)
```

## Distribution of S2 Vis
```{r}
# read in data
buses.sf <- readRDS("./exports/buses_sf.rds")
buses.s2.filt.true <- readRDS("./exports/buses_s2_filt_true.rds")

# plot distribution of voltages against normal voltages
ggplot() +
  geom_density(
    data = buses.sf,
    aes(x = voltage, fill = "Actual"),
    color = "forestgreen",
    alpha = 0.15,
    adjust = 3,
    size = 1.5
  ) +
  geom_density(
    data = buses.s2.filt.true,
    aes(x = voltage, weight = area, fill = "Plotted"),
    color = "#cbad03",
    alpha = 0.35,
    adjust = 3,
    size = 1.5
  ) +
  xlim(0.995, 1.04) +
  scale_fill_manual(
    name = element_blank(),
    values = c("Actual" = "forestgreen", "Plotted" = "gold")
  ) +
  labs(
    x = "Voltage [p.u.]",
    y = "Density"
  ) +
  theme(
    legend.position = c(0.9, 0.5),
    legend.background = element_rect(fill = "transparent"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    text = element_text(family = "Serif", size = 24)
  )
```

## Compute Statistics for S2 Tiles Filtered
```{r}
# read in data
buses.sf <- readRDS("./exports/buses_sf.rds")
buses.s2.filt.true <- readRDS("./exports/buses_s2_filt_true.rds")

# normalize area column
buses.s2.filt.true$area_norm <- buses.s2.filt.true$area / sum(buses.s2.filt.true$area)
buses.s2.filt.true$voltage_sample <- sample(buses.s2.filt.true$voltage, nrow(buses.s2.filt.true), replace = TRUE, prob = buses.s2.filt.true$area_norm)
set.seed(44)
voltage_sample_s2 <- sample(buses.s2.filt.true$voltage, 100*nrow(buses.s2.filt.true), replace = TRUE, prob = buses.s2.filt.true$area_norm)

# stats
(median(voltage_sample_s2))
(ks.test(buses.sf$voltage, voltage_sample_s2))
(IQR(voltage_sample_s2))
(var(voltage_sample_s2))
(sd(voltage_sample_s2))
(min(buses.s2.filt.true$voltage))
(min(buses.s2$voltage))
(max(buses.s2.filt.true$voltage))
(kurtosis(voltage_sample_s2))

# visuals
boxplot(voltage_sample_s2)
hist(voltage_sample_s2)
```

## Vioplot for S2
```{r}
# violin plot
library(vioplot)

par(family = "serif", cex = 1.2)
vioplot(buses.sf$voltage, ylim=c(0.94,1.07), side="left", at=0.97, xaxt='n', yaxt='n', horizontal = TRUE, col = "#929cfc")
vioplot(voltage_sample_s2, ylim=c(0.94,1.07), side="right", at=1.03, add=TRUE, horizontal = TRUE, col = "#fda99c")
title(xlab = "Voltage [p.u.]")
axis(1, at=c(0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0, 1.01, 1.02, 1.03, 1.04, 1.05, 1.06, 1.07))
axis(2, at=c(0.75, 1.25), tick=FALSE, labels = c("Actual", "| Visualized"))
abline(v=1.05, lty=2)
abline(v=.95, lty=2)
# abline(h=1, lty=1)
```

# Scratch Work
```{r}
# read in buses.sf
buses.sf <- readRDS("./exports/buses_sf.rds")

# show me outlier voltages in buses.sf
low <- buses.sf %>% filter(voltage < 0.90)

low
```